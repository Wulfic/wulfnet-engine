// =============================================================================
// WulfNet Engine - Marching Cubes Generate Compute Shader
// =============================================================================
// Second pass: generate triangles using prefix sum offsets
// Compile with: glslc -fshader-stage=compute marching_cubes_gen.comp -o marching_cubes_gen.spv
// =============================================================================

#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// =============================================================================
// Vertex output structure (32 bytes)
// =============================================================================
struct Vertex {
    vec3 position;
    float _pad1;
    vec3 normal;
    float _pad2;
};

// =============================================================================
// Edge table - which edges are cut for each cube configuration
// =============================================================================
const int edgeTable[256] = int[256](
    0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
    0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
    0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
    0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
    0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
    0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
    0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
    0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
);

// Triangle table - which edges form triangles (stored as SSBO due to size)
layout(std430, binding = 6) readonly buffer TriTableBuffer {
    int triTable[];  // 256 * 16 entries
};

// =============================================================================
// Buffers
// =============================================================================
layout(std430, binding = 0) readonly buffer DensityBuffer {
    float density[];
};

layout(std430, binding = 1) readonly buffer PrefixSumBuffer {
    uint prefixSum[];  // Prefix sum of triangle counts
};

layout(std430, binding = 2) writeonly buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 3) writeonly buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 4) buffer VertexCountBuffer {
    uint vertexCount;
};

layout(std430, binding = 5) buffer IndexCountBuffer {
    uint indexCount;
};

// =============================================================================
// Uniforms
// =============================================================================
layout(push_constant) uniform PushConstants {
    uint gridSizeX;
    uint gridSizeY;
    uint gridSizeZ;
    float cellSize;
    float isoLevel;
} params;

// =============================================================================
// Corner positions for each edge
// =============================================================================
const ivec2 edgeCorners[12] = ivec2[12](
    ivec2(0, 1), ivec2(1, 2), ivec2(2, 3), ivec2(3, 0),  // Bottom edges
    ivec2(4, 5), ivec2(5, 6), ivec2(6, 7), ivec2(7, 4),  // Top edges
    ivec2(0, 4), ivec2(1, 5), ivec2(2, 6), ivec2(3, 7)   // Vertical edges
);

const vec3 cornerOffsets[8] = vec3[8](
    vec3(0, 0, 0), vec3(1, 0, 0), vec3(1, 1, 0), vec3(0, 1, 0),
    vec3(0, 0, 1), vec3(1, 0, 1), vec3(1, 1, 1), vec3(0, 1, 1)
);

// =============================================================================
// Grid index
// =============================================================================
uint gridIndex(int i, int j, int k) {
    i = clamp(i, 0, int(params.gridSizeX) - 1);
    j = clamp(j, 0, int(params.gridSizeY) - 1);
    k = clamp(k, 0, int(params.gridSizeZ) - 1);
    return uint(i) + uint(j) * params.gridSizeX + uint(k) * params.gridSizeX * params.gridSizeY;
}

// =============================================================================
// Interpolate vertex position on edge
// =============================================================================
vec3 interpolateEdge(vec3 p1, vec3 p2, float d1, float d2) {
    if (abs(d1 - d2) < 1e-6) return p1;
    float t = (params.isoLevel - d1) / (d2 - d1);
    return mix(p1, p2, t);
}

// =============================================================================
// Compute normal from gradient
// =============================================================================
vec3 computeNormal(ivec3 gid) {
    float dx = density[gridIndex(gid.x + 1, gid.y, gid.z)] - 
               density[gridIndex(gid.x - 1, gid.y, gid.z)];
    float dy = density[gridIndex(gid.x, gid.y + 1, gid.z)] - 
               density[gridIndex(gid.x, gid.y - 1, gid.z)];
    float dz = density[gridIndex(gid.x, gid.y, gid.z + 1)] - 
               density[gridIndex(gid.x, gid.y, gid.z - 1)];
    return normalize(-vec3(dx, dy, dz));
}

// =============================================================================
// Main generation kernel
// =============================================================================
void main() {
    ivec3 gid = ivec3(gl_GlobalInvocationID);
    
    if (gid.x >= int(params.gridSizeX) - 1 ||
        gid.y >= int(params.gridSizeY) - 1 ||
        gid.z >= int(params.gridSizeZ) - 1)
        return;
    
    // Sample density at 8 corners
    float d[8];
    d[0] = density[gridIndex(gid.x,     gid.y,     gid.z)];
    d[1] = density[gridIndex(gid.x + 1, gid.y,     gid.z)];
    d[2] = density[gridIndex(gid.x + 1, gid.y + 1, gid.z)];
    d[3] = density[gridIndex(gid.x,     gid.y + 1, gid.z)];
    d[4] = density[gridIndex(gid.x,     gid.y,     gid.z + 1)];
    d[5] = density[gridIndex(gid.x + 1, gid.y,     gid.z + 1)];
    d[6] = density[gridIndex(gid.x + 1, gid.y + 1, gid.z + 1)];
    d[7] = density[gridIndex(gid.x,     gid.y + 1, gid.z + 1)];
    
    // Compute cube index
    uint cubeIndex = 0u;
    if (d[0] < params.isoLevel) cubeIndex |= 1u;
    if (d[1] < params.isoLevel) cubeIndex |= 2u;
    if (d[2] < params.isoLevel) cubeIndex |= 4u;
    if (d[3] < params.isoLevel) cubeIndex |= 8u;
    if (d[4] < params.isoLevel) cubeIndex |= 16u;
    if (d[5] < params.isoLevel) cubeIndex |= 32u;
    if (d[6] < params.isoLevel) cubeIndex |= 64u;
    if (d[7] < params.isoLevel) cubeIndex |= 128u;
    
    // Skip if no triangles
    int edges = edgeTable[cubeIndex];
    if (edges == 0) return;
    
    // Cell index for prefix sum lookup
    uint cellIdx = uint(gid.x) + uint(gid.y) * (params.gridSizeX - 1u) + 
                   uint(gid.z) * (params.gridSizeX - 1u) * (params.gridSizeY - 1u);
    
    // Get triangle offset from prefix sum
    uint triOffset = (cellIdx > 0u) ? prefixSum[cellIdx - 1u] : 0u;
    
    // Corner positions
    vec3 corners[8];
    vec3 basePos = vec3(gid) * params.cellSize;
    for (int i = 0; i < 8; ++i) {
        corners[i] = basePos + cornerOffsets[i] * params.cellSize;
    }
    
    // Interpolate edge vertices
    vec3 edgeVerts[12];
    for (int i = 0; i < 12; ++i) {
        if ((edges & (1 << i)) != 0) {
            int c1 = edgeCorners[i].x;
            int c2 = edgeCorners[i].y;
            edgeVerts[i] = interpolateEdge(corners[c1], corners[c2], d[c1], d[c2]);
        }
    }
    
    // Generate triangles
    uint baseVertIdx = atomicAdd(vertexCount, 0u);  // Get current count
    uint baseIdxIdx = atomicAdd(indexCount, 0u);
    
    int triIdx = 0;
    for (int i = 0; triTable[cubeIndex * 16 + i] != -1; i += 3) {
        int e0 = triTable[cubeIndex * 16 + i];
        int e1 = triTable[cubeIndex * 16 + i + 1];
        int e2 = triTable[cubeIndex * 16 + i + 2];
        
        uint vIdx = atomicAdd(vertexCount, 3u);
        uint iIdx = atomicAdd(indexCount, 3u);
        
        // Compute face normal
        vec3 v0 = edgeVerts[e0];
        vec3 v1 = edgeVerts[e1];
        vec3 v2 = edgeVerts[e2];
        vec3 normal = normalize(cross(v1 - v0, v2 - v0));
        
        // Store vertices
        vertices[vIdx].position = v0;
        vertices[vIdx].normal = normal;
        vertices[vIdx + 1u].position = v1;
        vertices[vIdx + 1u].normal = normal;
        vertices[vIdx + 2u].position = v2;
        vertices[vIdx + 2u].normal = normal;
        
        // Store indices
        indices[iIdx] = vIdx;
        indices[iIdx + 1u] = vIdx + 1u;
        indices[iIdx + 2u] = vIdx + 2u;
        
        triIdx++;
    }
}
